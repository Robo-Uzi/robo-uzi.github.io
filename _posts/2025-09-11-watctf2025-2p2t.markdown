---
layout: post
title:  "2p2t"
date:   2025-09-11 18:47:43 -0400
author: robo.uzi
tags: [ctf]
permalink: /watctf-2025-2p2t/
---

**Title:** 2p2t

**Category:** crypto

**Author:**  [virchau13](https://github.com/virchau13)

**Description:**  I've discovered a more efficient way to do RSA! There are no downsides to this approach, right?

I get this python file:
```shell
from Crypto.Util.number import getPrime, isPrime, bytes_to_long  
  
def nextPrime(k):  
   while not isPrime(k):  
       k += 1  
   return k  
  
p = getPrime(512)  
q = nextPrime(2*p)  
  
N = p*q  
e = 65537  
pt = bytes_to_long(open('flag.txt', 'rb').read())  
ct = pow(pt, e, N)  
  
print(f'N = {N}')  
print(f'e = {e}')  
print(f'ct = {ct}')
```

And this file:
```shell
cat output.txt  
N = 331952857868366988663932945877951080549278582595446041827767968625349664658283914707688360079014486835580798093875473318398665440196327017511963073666394378115620522693620625071360763670651867749935306771611365203669632958229266010553458203000895499490278056591308718235818336550276558946434347335414409026661  
e = 65537  
ct = 27392982072168505918328498224512439143304951239197916179225339049412270594576024668071218892690652612353376666973045187430259051892719839059780552668922042760370020764362839523844795479477997719361780814250593853162333527993824104731684172908271583213365558182307524519318252505075812038979585427505321346605
```

In normal RSA `p` and `q` are random and unrelated large primes. Here the challenge sets `q = nextPrime(2*p)`. 

This means `N = p*q = 2p^2`, so `p = sqrt(N/2)`. Once you get `p`, dividing `N` gives `q`. With `p` and `q`, compute the private key `d`, then decrypt `ct` to get the flag.

I run this:
```python
from math import isqrt
from Crypto.Util.number import long_to_bytes

N = 331952857868366988663932945877951080549278582595446041827767968625349664658283914707688360079014486835580798093875473318398665440196327017511963073666394378115620522693620625071360763670651867749935306771611365203669632958229266010553458203000895499490278056591308718235818336550276558946434347335414409026661
e = 65537
ct = 27392982072168505918328498224512439143304951239197916179225339049412270594576024668071218892690652612353376666973045187430259051892719839059780552668922042760370020764362839523844795479477997719361780814250593853162333527993824104731684172908271583213365558182307524519318252505075812038979585427505321346605

p = isqrt(N // 2)
while N % p != 0:
    p -= 1
q = N // p

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)
m = pow(ct, d, N)

print(long_to_bytes(m).decode())
```
`watctf{qu4dr4t1c_3qu4t10ns_l0ve_c0rr3l4t10n}`