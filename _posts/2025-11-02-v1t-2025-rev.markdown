---
layout: post
title:  "v1t 2025 Rev challenges"
date:   2025-11-02 17:19:10 -0400
author: robo.uzi
tags: [CTF]
permalink: /v1t-rev/
---
* TOC
{:toc}

## Snail Delivery

**Category**: rev

**Description**: Enter your flag and the snail will deliver it to headquarters for verification. But be careful - it moves slowly!

I get this file:
```shell
file snail  
snail: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=becf67c2c746e203cd1c1d8ea4cf3ab7e0c2ad1c, for GNU/Linux 3.2.0, not stripped
```

When I run it, it starts a "snail" moving slowly across the screen:
```shell
./snail  
Enter the flag: v1t{flag}  
The snail is sending the flag to headquarters to check...  
____@>^C
```

I open the binary in ghidra. This is the main function:
```t
undefined8 main(void)

{
  char *pcVar1;
  undefined8 uVar2;
  size_t sVar3;
  undefined8 local_178;
  undefined8 local_170;
  undefined8 local_168;
  undefined7 local_160;
  undefined uStack_159;
  undefined7 uStack_158;
  undefined4 local_151;
  undefined2 local_14d;
  byte input [267];
  void *local_40;
  size_t local_38;
  ulong local_30;
  int local_24;
  ulong local_20;
  int local_14;
  int local_10;
  uint local_c;
  
  printf("Enter the flag: ");
  pcVar1 = fgets((char *)(input + 3),0x100,stdin);
  if (pcVar1 == (char *)0x0) {
    uVar2 = 1;
  }
  else {
    sVar3 = strcspn((char *)(input + 3),"\n");
    input[sVar3 + 3] = 0;
    puts("The snail is sending the flag to headquarters to check...");
    local_c = 1;
    for (local_10 = 0; local_10 < 0x10; local_10 = local_10 + 1) {
      local_c = local_c << 1;
      putchar(0xd);
      for (local_14 = 0; local_14 < local_10; local_14 = local_14 + 1) {
        putchar(0x5f);
      }
      printf("@>");
      fflush(stdout);
      sleep(local_c);
    }
    input[0] = (byte)(local_c >> 0x10);
    input[1] = (byte)(local_c >> 8);
    input[2] = (byte)local_c;
    local_38 = strlen((char *)(input + 3));
    local_40 = malloc(local_38 + 1);
    if (local_40 == (void *)0x0) {
      uVar2 = 1;
    }
    else {
      for (local_20 = 0; local_20 < local_38; local_20 = local_20 + 1) {
        *(byte *)(local_20 + (long)local_40) = input[local_20 + 3] ^ input[local_20 % 3];
      }
      puts("\nWe have received it brother...");
      *(undefined *)(local_38 + (long)local_40) = 0;
      local_151 = 0xab784512;
      local_14d = 0xefcd;
      local_178 = 0x2c2781bed10c7465;
      local_170 = 0x990e747fdca9f514;
      local_168 = 0xb0ba9a14364c96bf;
      local_160 = 0x21dbfb99272327;
      uStack_159 = 0x75;
      uStack_158 = 0x38718eff9c4f;
      local_24 = 1;
      local_30 = 0;
      while( true ) {
        sVar3 = strlen((char *)(input + 3));
        if (sVar3 <= local_30) break;
        if (((int)(char)input[local_30 + 3] ^ (uint)*(byte *)((long)&local_151 + local_30 % 6)) !=
            (uint)*(byte *)((long)&local_178 + local_30)) {
          local_24 = 0;
          break;
        }
        local_30 = local_30 + 1;
      }
      if (local_24 == 0) {
        printf("Wut is ts");
      }
      else {
        printf("We check it, it was correct bro: %s\n",local_40);
      }
      free(local_40);
      uVar2 = 0;
    }
  }
  return uVar2;
}
```

First I reconstruct the target bytes from the constants in the main function:
```python
vals_and_lengths = [
    (0x2c2781bed10c7465, 8),
    (0x990e747fdca9f514, 8),
    (0xb0ba9a14364c96bf, 8),
    (0x21dbfb99272327,   7),
    (0x75,               1),
    (0x38718eff9c4f,     6)
]

# convert each integer to little endian bytes and concatenate
target_bytes = bytearray()
for val, length in vals_and_lengths:
    for i in range(length):
        target_bytes.append((val >> (8 * i)) & 0xff)

print(target_bytes.hex())
```

Output:
```shell
python3 target-bytes.py  
65740cd1be81272c14f5a9dc7f740e99bf964c36149abab027232799fbdb21754f9cff8e7138
```

Then I get the key bytes from the constants also in the main function:
```d
local_151 = 0xab784512;
local_14d = 0xefcd;
```
The key bytes are `0x12,0x45,0x78,0xab,0xcd,0xef`.

So the program reads the input string into `input + 3` (so the first character is `input[3]`). Then it runs a sleep animation loop that ends then writes:
```d
input[0] = (byte)(local_c >> 0x10);
input[1] = (byte)(local_c >> 8);
input[2] = (byte)local_c;
```
The repeating 3 byte mask in memory becomes `[0x01, 0x00, 0x00]`. 

Then it allocates `local_40` then does:
```d
local_40[i] = input[i+3] ^ input[i % 3]
```
So the input XORed with the repeating 3 byte value at `input[0]-[2]`. 

I run this script to recover the flag:
```python
# key (little endian)
key = bytes([0x12,0x45,0x78,0xab,0xcd,0xef])

# target bytes
target_hex = "65740cd1be81272c14f5a9dc7f740e99bf964c36149abab027232799fbdb21754f9cff8e7138"
target = bytes.fromhex(target_hex)

# required input that passes the check
input_bytes = bytes([b ^ key[i % 6] for i,b in enumerate(target)])

mask = [1,0,0]
printed = bytes([input_bytes[i] ^ mask[i % 3] for i in range(len(input_bytes))])

print("input (raw):", input_bytes.decode('utf-8'))
print("printed flag:", printed.decode('utf-8'))
```

Output:
```shell
python3 reverse1.py  
input (raw): w1tzsn5il^d3m1v2ry^sl1w_5f_26430772ac}  
printed flag: v1t{sn4il_d3l1v3ry_sl0w_4f_36420762ab}
```

`v1t{sn4il_d3l1v3ry_sl0w_4f_36420762ab}`

___

## Optimus

**Category**: rev

**Description**: uu ee ac ac

I get this file:
```shell
file optimus  
optimus: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bef22db314be57287a814871ff6b1e52060d202a, for GNU/Linux 3.2.0, not stripped
```

I find the main function:
```t
undefined8 main(void)

{
  char isPrime;
  size_t sVar1;
  char *fgets_result;
  undefined8 result;
  undefined8 probably_junk_maybe;
  char input [268];
  int target_length;
  char *reference_flag;
  int j;
  int input_index;
  size_t input_length;
  int i;
  int prime_count;
  
  reference_flag = "0ov13tc{9zxpdr6na13m6a73534th5a}";
  probably_junk_maybe = 0x1011f0;
  sVar1 = strlen("0ov13tc{9zxpdr6na13m6a73534th5a}");
  target_length = (int)sVar1;
  prime_count = 0;
  for (i = 0; i < target_length; i = i + 1) {
    probably_junk_maybe = 0x10120d;
    isPrime = is_prime(i);
    if (isPrime != '\0') {
      prime_count = prime_count + 1;
    }
  }
  probably_junk_maybe = 0x101235;
  printf("Input flag: ");
  probably_junk_maybe = 0x101250;
  fgets_result = fgets(input,0x100,stdin);
  if (fgets_result == (char *)0x0) {
    result = 2;
  }
  else {
    probably_junk_maybe = 0x10126e;
    input_length = strlen(input);
    while ((input_length != 0 &&
           ((input[input_length - 1] == '\n' || (input[input_length - 1] == '\r'))))) {
      input[input_length - 1] = '\0';
      probably_junk_maybe = 0x101293;
      input_length = strlen(input);
    }
    if (prime_count == (int)input_length) {
      input_index = 0;
      for (j = 0; j < target_length; j = j + 1) {
        probably_junk_maybe = 0x1012ff;
        isPrime = is_prime(j);
        if (isPrime == '\x01') {
          if (input[input_index] != reference_flag[j]) {
            probably_junk_maybe = 0x101336;
            puts("WRONG FLAG ");
            return 1;
          }
          input_index = input_index + 1;
        }
      }
      probably_junk_maybe = 0x10135f;
      puts("FLAG OK QUACK ");
      result = 0;
    }
    else {
      probably_junk_maybe = 0x1012de;
      puts("WRONG FLAG ");
      result = 1;
    }
  }
  return result;
}
```

I need a script that first finds the prime indices in the string `"0ov13tc{9zxpdr6na13m6a73534th5a}"`. Then take the characters in those indices and concatenate:
```python
s = "0ov13tc{9zxpdr6na13m6a73534th5a}"

def is_prime(n):
    if n < 2:
        return False
    for k in range(2, int(n**0.5) + 1):
        if n % k == 0:
            return False
    return True

flag = ''.join(c for i, c in enumerate(s) if is_prime(i))
print(flag)
```

`v1t{pr1m35}`

___

## Duck RPG

**Category**: rev

**Description**: Can you patch the batch to get the secret ending of the game?

I get the files `game.bat` and `result.bat`:
```shell
file *  
game.bat:   DOS batch file, ASCII text, with CRLF line terminators  
result.bat: Unicode text, UTF-16, little-endian text, with very long lines (1576), with no line terminators
```

`game.bat` contains this:
```shell
@echo off  
setlocal EnableDelayedExpansion  
  
:mainmenu  
cls  
echo ==========================  
echo        DUCK RPG  
echo ==========================  
echo.  
echo 1. Start Adventure  
echo 2. Quit  
echo.  
set /p choice=Choose:    
if "%choice%"=="1" goto intro  
if "%choice%"=="2" exit  
goto mainmenu  
  
:intro  
cls  
echo In a world overrun by evil ducks...  
echo Only YOU can stop the feathery menace.  
set /a hero_hp=100  
pause  
goto battle1  
  
:battle1  
call :fight "Angry Duck" 50 8  
if "!hero_dead!"=="1" goto gameover  
set "frag1=unlock"  
goto battle2  
  
:battle2  
call :fight "Duck Mage" 100 12  
if "!hero_dead!"=="1" goto gameover  
set "frag2=the"  
goto battle3  
  
:battle3  
call :fight "Mother Goose" 420 69  
if "!hero_dead!"=="1" goto gameover  
set "frag3=goose"  
goto victory  
  
:victory  
cls  
echo You defeated all the evil ducks!  
echo The pond is safe again, hero.  
set "full=%frag1%%frag2%%frag3%"  
set "self=%~f0"  
set "hash="  
for /f "skip=1 tokens=1" %%H in ('certutil -hashfile "%self%" SHA256') do (  
   call set "hash=%%H"  
   goto result  
)  
  
:result  
call result.bat !full! !hash!  
exit /b  
  
:gameover  
echo You were defeated by the ducks...  
echo Try again, brave one.  
exit /b  
goto mainmenu  
  
:fight  
  
set "enemy_name=%~1"  
set /a enemy_hp=%~2  
set /a enemy_atk=%~3  
set hero_dead=0  
  
:combat  
cls  
echo ==========================  
echo Battle: !enemy_name!  
echo ==========================  
echo Your HP: !hero_hp!  
echo !enemy_name! HP: !enemy_hp!  
echo.  
echo 1. Attack  
echo 2. Heal (+10 HP)  
echo 3. Run  
set /p act=Action:    
  
if "!act!"=="1" (  
   set /a enemy_hp-=10  
   echo You hit !enemy_name! for 10!  
) else if "!act!"=="2" (  
   set /a hero_hp+=10  
   echo You healed 10 HP!  
) else if "!act!"=="3" (  
   echo You cannot run from ducks!    
) else (  
   echo Invalid.  
)  
  
if !enemy_hp! LEQ 0 (  
   echo.  
   echo You defeated !enemy_name!  
   goto :eof  
)  
  
set /a dmg=%random% %% %enemy_atk% + 5  
set /a hero_hp-=dmg  
echo.  
echo !enemy_name! hits you for !dmg! damage!  
  
if !hero_hp! LEQ 0 (  
   set "hero_dead=1"  
   endlocal & set "hero_dead=1"  
   goto :eof  
)  
  
pause  
goto combat  
  
:battle0  
call :fight "Tiny Duck" 1 1  
if "!hero_dead!"=="1" goto gameover  
set "frag3=duck"  
goto victory
```

I changed multiple things at once. First I changed the line in `:battle2` from `goto battle3` to `goto battle0`.

After running strings on `result.bat` I find a hash used for a check:
```shell
strings -n 10 result.bat  
&@cls&@set "  
=@1lYWZUrksK9Mwxd2PLGypH68fOStF4Abaq3zXDeuJNRc Bo7h0gvni5IjmCTQVE"  
:~45,1%"%~1"=="" (  
:~45,1%"%~2"=="8392dcc7b6fdebd5a70211c1e21497a553b31f2c70408b772c4a313615df7b60" 
:~45,1%"%~1"=="unlocktheduck" (  
:~45,1%"%~1"=="unlockthegoose" (
```

In `:victory` I replace the hash check from:
```shell
set "hash=" 
for /f "skip=1 tokens=1" %%H in ('certutil -hashfile "%self%" SHA256') do ( 
	call set "hash=%%H" 
	goto result 
)
```
to this: 
```shell
set "hash=8392dcc7b6fdebd5a70211c1e21497a553b31f2c70408b772c4a313615df7b60"
```

Then I set all the enemies health to 10 and start the game with `wine cmd /c game.bat`. I play through it quickly and get the flag.

`v1t{p4tch_th3_b4tch_t0_g3t_th3_s3cr3t_3nd1ng}`

___

## Python 0bf

**Category**: rev

**Description**: You don't need to deobfuscate the Python, but that's up to you. ;-;

I get this the file `obs.py` that contains this (output shortened):
```python
_ = lambda __ : __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]));exec((_)(b'==A4ZjPKD8/33n//U2qxMQkZ9we64U+EQgjaoDsX0As1ciswNm7rrDho3J7Tqho5C86HA3DBQ0kA  
qiI1Q0CLDEDw2jOnh/WbW6BDYKwgx2kwGyk+q8D7SNJb5Dxi4ddljVHxr+cyJxu5Y0+s2YSfhRHnYmwmqv+++iCRpBNC+gQn+QzM2jXYXTkIECLseVCqrcmViZTfJrPgdiFPrYa2wJl9JU7MDNExi/FggwhJzXBKN8xSqyEszzqRO913LcPCv4KOSOqEzkD8rvGm0xVZObFGYVRIzvTTTYkJ/ee3PU7P9wE5qC1Ko9UQKKmeSDupSi/59Uro9DTwOZPDVQmEtUnQ5tPy7F2APluBImAj4ZKlxb2anJBwfMT2elM2QgDOyk/i/789IPe5gSyAoJgiR3iXqkHH/z6ms4MxES4UW85YPbDCVTdsc4XFCHJGCBZtPPY9dq0flvAKPIUQuqiQYZ8i5g36Kfh/bFH3PAegrwrRzIRyLN9nam0pt/GT8WYkknqbKMrIbM41jS/ViDyJzCBgOWMYb3Zaa0RM1VZQVCzANFaHL8rpp2F2vvdYsX+dk8DwXWLa+rS9jf+Boul2jfYcCM5EJ3ST/YOUwA/xXtsEk+u2tzg/r7ZnCA9d2DMD+3eX5JIIHlWTb0ACTBfL8pK09fdASJMxCWfO+W2j70OHVYu0eq1vVvE+5iWGsSjwJy0zR7LNtqQhaLNyy+cv2d532j6b/arT1EljCd7yLzo/LNfndapZdkgqEgizlsArSPuoqvOkTSUH2pQZiylLrQ9tn9kdGvKkoTVh7RHLp6aMrD424Z75Lex2Y43AJAcQ+XVbuM3KzYGHsBoZ/zUbvq8t4rcBzBEUYcHjF0azOfXQg79SlDg4CoeFW5WoDz9nUMT+qiic/mfUjdugP18l7oi2b5EenW4BYRStH4zBKBDXxliwfF8IOq2rMHffauJ4stWVFISIx7m6DwC7VZAYynwts7UXXG/3XOQg7zz8dHF6uYs8R56KlvJOD+O0s9YX9'))
```

I go to [https://pyobfuscate.com/deobf](https://pyobfuscate.com/deobf) and enter the python. I get this output:
```python
flag = "v1t{d4ng_u_kn0w_pyth0n_d3bugg}"

inp = input("Input the flag: ")

if (inp != flag):
    print("wrong")
else:
    print("correct")
```

`v1t{d4ng_u_kn0w_pyth0n_d3bugg}`
